(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{DeP4:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export initialResolution */\n/* unused harmony export hash */\n/* unused harmony export pointToTile */\n/* unused harmony export pointToTileFraction */\n/* unused harmony export bboxToCenter */\n/* unused harmony export lngLatToMeters */\n/* unused harmony export metersToLngLat */\n/* unused harmony export metersToPixels */\n/* unused harmony export lngLatToTile */\n/* unused harmony export lngLatToGoogle */\n/* unused harmony export metersToTile */\n/* unused harmony export pixelsToMeters */\n/* unused harmony export pixelsToTile */\n/* unused harmony export tileToBBoxMeters */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return tileToBBox; });\n/* unused harmony export googleToBBoxMeters */\n/* unused harmony export googleToBBox */\n/* unused harmony export tileToGoogle */\n/* unused harmony export googleToTile */\n/* unused harmony export googleToQuadkey */\n/* unused harmony export tileToQuadkey */\n/* unused harmony export quadkeyToTile */\n/* unused harmony export quadkeyToGoogle */\n/* unused harmony export bboxToMeters */\n/* unused harmony export validateTile */\n/* unused harmony export wrapTile */\n/* unused harmony export validateZoom */\n/* unused harmony export validateLngLat */\n/* unused harmony export resolution */\n/* unused harmony export range */\n/* unused harmony export maxBBox */\n/* unused harmony export validTile */\n/* unused harmony export latitude */\n/* unused harmony export longitude */\n/* unused harmony export bboxToTile */\nvar originShift = 2 * Math.PI * 6378137 / 2.0\nvar d2r = Math.PI / 180\n\nfunction initialResolution (tileSize) {\n  tileSize = tileSize || 256\n  return 2 * Math.PI * 6378137 / tileSize\n}\n\n/**\n * Hash tile for unique id key\n *\n * @param {Tile} tile [x, y, z]\n * @returns {number} hash\n * @example\n * var id = globalMercator.hash([312, 480, 4])\n * //=5728\n */\nfunction hash (tile) {\n  var x = tile[0]\n  var y = tile[1]\n  var z = tile[2]\n  return (1 << z) * ((1 << z) + x) + y\n}\n\n/**\n * Get the tile for a point at a specified zoom level\n * https://github.com/mapbox/tilebelt\n *\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @returns {Google} Google (XYZ) Tile\n * @example\n * var tile = globalMercator.pointToTile([1, 1], 12)\n * //= [ 2059, 2036, 12 ]\n */\nfunction pointToTile (lnglat, zoom, validate) {\n  var tile = pointToTileFraction(lnglat, zoom, validate)\n  tile[0] = Math.floor(tile[0])\n  tile[1] = Math.floor(tile[1])\n  return tile\n}\n\n/**\n * Get the precise fractional tile location for a point at a zoom level\n * https://github.com/mapbox/tilebelt\n *\n * @name pointToTileFraction\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @returns {Google} Google (XYZ) Tile\n * @example\n * var tile = globalMercator.pointToTileFraction([1, 1], 12)\n * //= [ 2059.3777777777777, 2036.6216445333432, 12 ]\n */\nfunction pointToTileFraction (lnglat, zoom, validate) {\n  // lnglat = validateLngLat(lnglat, validate)\n  var z = zoom\n  var lon = longitude(lnglat[0])\n  var lat = latitude(lnglat[1])\n  var sin = Math.sin(lat * d2r)\n  var z2 = Math.pow(2, z)\n  var x = z2 * (lon / 360 + 0.5)\n  var y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI)\n  return validateTile([x, y, z], validate)\n}\n\n/**\n * Converts BBox to Center\n *\n * @param {BBox} bbox - [west, south, east, north] coordinates\n * @return {LngLat} center\n * @example\n * var center = globalMercator.bboxToCenter([90, -45, 85, -50])\n * //= [ 87.5, -47.5 ]\n */\nfunction bboxToCenter (bbox) {\n  var west = bbox[0]\n  var south = bbox[1]\n  var east = bbox[2]\n  var north = bbox[3]\n  var lng = (west - east) / 2 + east\n  var lat = (south - north) / 2 + north\n  lng = Number(lng.toFixed(6))\n  lat = Number(lat.toFixed(6))\n  return [lng, lat]\n}\n\n/**\n * Converts LngLat coordinates to Meters coordinates.\n *\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @returns {Meters} Meters coordinates\n * @example\n * var meters = globalMercator.lngLatToMeters([126, 37])\n * //=[ 14026255.8, 4439106.7 ]\n */\nfunction lngLatToMeters (lnglat, validate) {\n  lnglat = validateLngLat(lnglat, validate)\n  var lng = lnglat[0]\n  var lat = lnglat[1]\n  var x = lng * originShift / 180.0\n  var y = Math.log(Math.tan((90 + lat) * Math.PI / 360.0)) / (Math.PI / 180.0)\n  y = y * originShift / 180.0\n  x = Number(x.toFixed(1))\n  y = Number(y.toFixed(1))\n  return [x, y]\n}\n\n/**\n * Converts Meters coordinates to LngLat coordinates.\n *\n * @param {Meters} meters Meters in Mercator [x, y]\n * @returns {LngLat} LngLat coordinates\n * @example\n * var lnglat = globalMercator.metersToLngLat([14026255, 4439106])\n * //=[ 126, 37 ]\n */\nfunction metersToLngLat (meters) {\n  var x = meters[0]\n  var y = meters[1]\n  var lng = (x / originShift) * 180.0\n  var lat = (y / originShift) * 180.0\n  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0)\n  lng = Number(lng.toFixed(6))\n  lat = Number(lat.toFixed(6))\n  return [lng, lat]\n}\n\n/**\n * Converts Meters coordinates to Pixels coordinates.\n *\n * @param {Meters} meters Meters in Mercator [x, y]\n * @param {number} zoom Zoom level\n * @param {number} [tileSize=256] Tile size\n * @returns {Pixels} Pixels coordinates\n * @example\n * var pixels = globalMercator.metersToPixels([14026255, 4439106], 13)\n * //=[ 1782579.1, 1280877.3, 13 ]\n */\nfunction metersToPixels (meters, zoom, tileSize) {\n  var x = meters[0]\n  var y = meters[1]\n  var res = resolution(zoom, tileSize)\n  var px = (x + originShift) / res\n  var py = (y + originShift) / res\n  return [px, py, zoom]\n}\n\n/**\n * Converts LngLat coordinates to TMS Tile.\n *\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @returns {Tile} TMS Tile\n * @example\n * var tile = globalMercator.lngLatToTile([126, 37], 13)\n * //=[ 6963, 5003, 13 ]\n */\nfunction lngLatToTile (lnglat, zoom, validate) {\n  lnglat = validateLngLat(lnglat, validate)\n  var meters = lngLatToMeters(lnglat)\n  var pixels = metersToPixels(meters, zoom)\n  return pixelsToTile(pixels)\n}\n\n/**\n * Converts LngLat coordinates to Google (XYZ) Tile.\n *\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @returns {Google} Google (XYZ) Tile\n * @example\n * var google = globalMercator.lngLatToGoogle([126, 37], 13)\n * //=[ 6963, 3188, 13 ]\n */\nfunction lngLatToGoogle (lnglat, zoom, validate) {\n  lnglat = validateLngLat(lnglat, validate)\n\n  if (zoom === 0) {\n    return [0, 0, 0]\n  }\n  var tile = lngLatToTile(lnglat, zoom)\n  return tileToGoogle(tile)\n}\n\n/**\n * Converts Meters coordinates to TMS Tile.\n *\n * @param {Meters} meters Meters in Mercator [x, y]\n * @param {number} zoom Zoom level\n * @returns {Tile} TMS Tile\n * @example\n * var tile = globalMercator.metersToTile([14026255, 4439106], 13)\n * //=[ 6963, 5003, 13 ]\n */\nfunction metersToTile (meters, zoom) {\n  if (zoom === 0) {\n    return [0, 0, 0]\n  }\n  var pixels = metersToPixels(meters, zoom)\n  return pixelsToTile(pixels)\n}\n\n/**\n * Converts Pixels coordinates to Meters coordinates.\n *\n * @param {Pixels} pixels Pixels [x, y, zoom]\n * @param {number} [tileSize=256] Tile size\n * @returns {Meters} Meters coordinates\n * @example\n * var meters = globalMercator.pixelsToMeters([1782579, 1280877, 13])\n * //=[ 14026252.0, 4439099.5 ]\n */\nfunction pixelsToMeters (pixels, tileSize) {\n  var px = pixels[0]\n  var py = pixels[1]\n  var zoom = pixels[2]\n  var res = resolution(zoom, tileSize)\n  var mx = px * res - originShift\n  var my = py * res - originShift\n  mx = Number(mx.toFixed(1))\n  my = Number(my.toFixed(1))\n  return [mx, my]\n}\n\n/**\n * Converts Pixels coordinates to TMS Tile.\n *\n * @param {Pixels} pixels Pixels [x, y, zoom]\n * @param {number} [tileSize=256] Tile size\n * @param {boolean} [validate=true] validates Pixels coordinates\n * @returns {Tile} TMS Tile\n * @example\n * var tile = globalMercator.pixelsToTile([1782579, 1280877, 13])\n * //=[ 6963, 5003, 13 ]\n */\nfunction pixelsToTile (pixels, tileSize, validate) {\n  tileSize = tileSize || 256\n  var px = pixels[0]\n  var py = pixels[1]\n  var zoom = pixels[2]\n  if (zoom === 0) return [0, 0, 0]\n\n  validateZoom(zoom, validate)\n  var tx = Math.ceil(px / tileSize) - 1\n  var ty = Math.ceil(py / tileSize) - 1\n  if (tx < 0) tx = 0\n  if (ty < 0) ty = 0\n  return [tx, ty, zoom]\n}\n\n/**\n * Converts TMS Tile to bbox in Meters coordinates.\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @param {number} x TMS Tile X\n * @param {number} y TMS Tile Y\n * @param {number} zoom Zoom level\n * @param {number} [tileSize=256] Tile size\n * @param {boolean} [validate=true] validates Tile\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var bbox = globalMercator.tileToBBoxMeters([6963, 5003, 13])\n * //=[ 14025277.4, 4437016.6, 14030169.4, 4441908.5 ]\n */\nfunction tileToBBoxMeters (tile, tileSize, validate) {\n  validateTile(tile, validate)\n\n  tileSize = tileSize || 256\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n  var min = pixelsToMeters([tx * tileSize, ty * tileSize, zoom])\n  var max = pixelsToMeters([(tx + 1) * tileSize, (ty + 1) * tileSize, zoom])\n  return [min[0], min[1], max[0], max[1]]\n}\n\n/**\n * Converts TMS Tile to bbox in LngLat coordinates.\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @param {number} x TMS Tile X\n * @param {number} y TMS Tile Y\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates Tile\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var bbox = globalMercator.tileToBBox([6963, 5003, 13])\n * //=[ 125.991, 36.985, 126.035, 37.020 ]\n */\nfunction tileToBBox (tile, validate) {\n  validateTile(tile, validate)\n\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n  if (zoom === 0) {\n    return [-180, -85.051129, 180, 85.051129]\n  }\n  var bbox = tileToBBoxMeters([tx, ty, zoom])\n  var mx1 = bbox[0]\n  var my1 = bbox[1]\n  var mx2 = bbox[2]\n  var my2 = bbox[3]\n  var min = metersToLngLat([mx1, my1, zoom])\n  var max = metersToLngLat([mx2, my2, zoom])\n  return [min[0], min[1], max[0], max[1]]\n}\n\n/**\n * Converts Google (XYZ) Tile to bbox in Meters coordinates.\n *\n * @param {Google} google Google [x, y, zoom]\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var bbox = globalMercator.googleToBBoxMeters([6963, 3188, 13])\n * //=[ 14025277.4, 4437016.6, 14030169.4, 4441908.5 ]\n */\nfunction googleToBBoxMeters (google) {\n  var Tile = googleToTile(google)\n  return tileToBBoxMeters(Tile)\n}\n\n/**\n * Converts Google (XYZ) Tile to bbox in LngLat coordinates.\n *\n * @param {Google} google Google [x, y, zoom]\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var bbox = globalMercator.googleToBBox([6963, 3188, 13])\n * //=[ 125.991, 36.985, 126.035, 37.020 ]\n */\nfunction googleToBBox (google) {\n  var Tile = googleToTile(google)\n  return tileToBBox(Tile)\n}\n\n/**\n * Converts TMS Tile to Google (XYZ) Tile.\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @param {boolean} [validate=true] validates Tile\n * @returns {Google} Google (XYZ) Tile\n * @example\n * var google = globalMercator.tileToGoogle([6963, 5003, 13])\n * //=[ 6963, 3188, 13 ]\n */\nfunction tileToGoogle (tile, validate) {\n  validateTile(tile, validate)\n\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n  if (zoom === 0) {\n    return [0, 0, 0]\n  }\n  var x = tx\n  var y = (Math.pow(2, zoom) - 1) - ty\n  return [x, y, zoom]\n}\n\n/**\n * Converts Google (XYZ) Tile to TMS Tile.\n *\n * @param {Google} google Google [x, y, zoom]\n * @returns {Tile} TMS Tile\n * @example\n * var tile = globalMercator.googleToTile([6963, 3188, 13])\n * //=[ 6963, 5003, 13 ]\n */\nfunction googleToTile (google) {\n  var x = google[0]\n  var y = google[1]\n  var zoom = google[2]\n  var tx = x\n  var ty = Math.pow(2, zoom) - y - 1\n  return [tx, ty, zoom]\n}\n\n/**\n * Converts Google (XYZ) Tile to Quadkey.\n *\n * @param {Google} google Google [x, y, zoom]\n * @returns {string} Microsoft's Quadkey schema\n * @example\n * var quadkey = globalMercator.googleToQuadkey([6963, 3188, 13])\n * //='1321102330211'\n */\nfunction googleToQuadkey (google) {\n  var Tile = googleToTile(google)\n  return tileToQuadkey(Tile)\n}\n\n/**\n * Converts TMS Tile to QuadKey.\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @param {boolean} [validate=true] validates Tile\n * @returns {string} Microsoft's Quadkey schema\n * @example\n * var quadkey = globalMercator.tileToQuadkey([6963, 5003, 13])\n * //='1321102330211'\n */\nfunction tileToQuadkey (tile, validate) {\n  validateTile(tile, validate)\n\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n  // Zoom 0 does not exist for Quadkey\n  if (zoom === 0) {\n    return ''\n  }\n  var quadkey = ''\n  ty = (Math.pow(2, zoom) - 1) - ty\n  range(zoom, 0, -1).map(function (i) {\n    var digit = 0\n    var mask = 1 << (i - 1)\n    if ((tx & mask) !== 0) {\n      digit += 1\n    }\n    if ((ty & mask) !== 0) {\n      digit += 2\n    }\n    quadkey = quadkey.concat(digit)\n  })\n  return quadkey\n}\n\n/**\n * Converts Quadkey to TMS Tile.\n *\n * @param {string} quadkey Microsoft's Quadkey schema\n * @returns {Tile} TMS Tile\n * @example\n * var tile = globalMercator.quadkeyToTile('1321102330211')\n * //=[ 6963, 5003, 13 ]\n */\nfunction quadkeyToTile (quadkey) {\n  var Google = quadkeyToGoogle(quadkey)\n  return googleToTile(Google)\n}\n\n/**\n * Converts Quadkey to Google (XYZ) Tile.\n *\n * @param {string} quadkey Microsoft's Quadkey schema\n * @returns {Google} Google (XYZ) Tile\n * @example\n * var google = globalMercator.quadkeyToGoogle('1321102330211')\n * //=[ 6963, 3188, 13 ]\n */\nfunction quadkeyToGoogle (quadkey) {\n  var x = 0\n  var y = 0\n  var zoom = quadkey.length\n  range(zoom, 0, -1).map(function (i) {\n    var mask = 1 << (i - 1)\n    switch (parseInt(quadkey[zoom - i], 0)) {\n      case 0:\n        break\n      case 1:\n        x += mask\n        break\n      case 2:\n        y += mask\n        break\n      case 3:\n        x += mask\n        y += mask\n        break\n      default:\n        throw new Error('Invalid Quadkey digit sequence')\n    }\n  })\n  return [x, y, zoom]\n}\n\n/**\n * Converts BBox from LngLat coordinates to Meters coordinates\n *\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var meters = globalMercator.bboxToMeters([ 125, 35, 127, 37 ])\n * //=[ 13914936.3, 4163881.1, 14137575.3, 4439106.7 ]\n */\nfunction bboxToMeters (bbox) {\n  var min = lngLatToMeters([bbox[0], bbox[1]])\n  var max = lngLatToMeters([bbox[2], bbox[3]])\n  return [min[0], min[1], max[0], max[1]]\n}\n\n/**\n * Validates TMS Tile.\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @param {boolean} [validate=true] validates Tile\n * @throws {Error} Will throw an error if TMS Tile is not valid.\n * @returns {Tile} TMS Tile\n * @example\n * globalMercator.validateTile([60, 80, 12])\n * //=[60, 80, 12]\n * globalMercator.validateTile([60, -43, 5])\n * //= Error: Tile <y> must not be less than 0\n * globalMercator.validateTile([25, 60, 3])\n * //= Error: Illegal parameters for tile\n */\nfunction validateTile (tile, validate) {\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n  if (validate === false) return tile\n  if (zoom === undefined || zoom === null) throw new Error('<zoom> is required')\n  if (tx === undefined || tx === null) throw new Error('<x> is required')\n  if (ty === undefined || ty === null) throw new Error('<y> is required')\n\n  // Adjust values of tiles to fit within tile scheme\n  zoom = validateZoom(zoom)\n  tile = wrapTile(tile)\n\n  // // Check to see if tile is valid based on the zoom level\n  // // Currently impossible to hit since WrapTile handles this error\n  // // will keep this test commented out in case it doesnt handle it\n  // var maxCount = Math.pow(2, zoom)\n  // if (tile[0] >= maxCount || tile[1] >= maxCount) throw new Error('Illegal parameters for tile')\n  return tile\n}\n\n/**\n * Wrap Tile -- Handles tiles which crosses the 180th meridian or 90th parallel\n *\n * @param {[number, number, number]} tile Tile\n * @param {number} zoom Zoom Level\n * @returns {[number, number, number]} Wrapped Tile\n * @example\n * globalMercator.wrapTile([0, 3, 2])\n * //= [0, 3, 2] -- Valid Tile X\n * globalMercator.wrapTile([4, 2, 2])\n * //= [0, 2, 2] -- Tile 4 does not exist, wrap around to TileX=0\n */\nfunction wrapTile (tile) {\n  var tx = tile[0]\n  var ty = tile[1]\n  var zoom = tile[2]\n\n  // Maximum tile allowed\n  // zoom 0 => 1\n  // zoom 1 => 2\n  // zoom 2 => 4\n  // zoom 3 => 8\n  var maxTile = Math.pow(2, zoom)\n\n  // Handle Tile X\n  tx = tx % maxTile\n  if (tx < 0) tx = tx + maxTile\n\n  return [tx, ty, zoom]\n}\n\n/**\n * Validates Zoom level\n *\n * @param {number} zoom Zoom level\n * @param {boolean} [validate=true] validates Zoom level\n * @throws {Error} Will throw an error if zoom is not valid.\n * @returns {number} zoom Zoom level\n * @example\n * globalMercator.validateZoom(12)\n * //=12\n * globalMercator.validateZoom(-4)\n * //= Error: <zoom> cannot be less than 0\n * globalMercator.validateZoom(32)\n * //= Error: <zoom> cannot be greater than 30\n */\nfunction validateZoom (zoom) {\n  if (zoom === false) return zoom\n  if (zoom === undefined || zoom === null) { throw new Error('<zoom> is required') }\n  if (zoom < 0) { throw new Error('<zoom> cannot be less than 0') }\n  if (zoom > 32) { throw new Error('<zoom> cannot be greater than 32') }\n  return zoom\n}\n\n/**\n * Validates LngLat coordinates\n *\n * @param {[number, number]} lnglat [Longitude, Latitude]\n * @param {boolean} [validate=true] validates LatLng coordinates\n * @throws {Error} Will throw an error if LngLat is not valid.\n * @returns {LngLat} LngLat coordinates\n * @example\n * globalMercator.validateLngLat([-115, 44])\n * //= [ -115, 44 ]\n * globalMercator.validateLngLat([-225, 44])\n * //= Error: LngLat [lng] must be within -180 to 180 degrees\n */\nfunction validateLngLat (lnglat, validate) {\n  if (validate === false) return lnglat\n\n  var lng = longitude(lnglat[0])\n  var lat = latitude(lnglat[1])\n\n  // Global Mercator does not support latitudes within 85 to 90 degrees\n  if (lat > 85) lat = 85\n  if (lat < -85) lat = -85\n  return [lng, lat]\n}\n\n/**\n * Retrieve resolution based on zoom level\n *\n * @private\n * @param {number} zoom zoom level\n * @param {number} [tileSize=256] Tile size\n * @returns {number} resolution\n * @example\n * var res = globalMercator.resolution(13)\n * //=19.109257071294063\n */\nfunction resolution (zoom, tileSize) {\n  return initialResolution(tileSize) / Math.pow(2, zoom)\n}\n\n/**\n * Generate an integer Array containing an arithmetic progression.\n *\n * @private\n * @param {number} [start=0] Start\n * @param {number} stop Stop\n * @param {number} [step=1] Step\n * @returns {number[]} range\n * @example\n * globalMercator.range(3)\n * //=[ 0, 1, 2 ]\n * globalMercator.range(3, 6)\n * //=[ 3, 4, 5 ]\n * globalMercator.range(6, 3, -1)\n * //=[ 6, 5, 4 ]\n */\nfunction range (start, stop, step) {\n  if (stop == null) {\n    stop = start || 0\n    start = 0\n  }\n  if (!step) {\n    step = stop < start ? -1 : 1\n  }\n  var length = Math.max(Math.ceil((stop - start) / step), 0)\n  var range = Array(length)\n  for (var idx = 0; idx < length; idx++, start += step) {\n    range[idx] = start\n  }\n  return range\n}\n\n/**\n * Maximum extent of BBox\n *\n * @param {BBox|BBox[]} array BBox [west, south, east, north]\n * @returns {BBox} Maximum BBox\n * @example\n * var bbox = globalMercator.maxBBox([[-20, -30, 20, 30], [-110, -30, 120, 80]])\n * //=[-110, -30, 120, 80]\n */\nfunction maxBBox (array) {\n  if (!array) throw new Error('array is required')\n\n  // Single BBox\n  if (array && array[0] && array.length === 4 && array[0][0] === undefined) {\n    return array\n  }\n\n  // Multiple BBox\n  if (array && array[0] && array[0][0] !== undefined) {\n    var west = array[0][0]\n    var south = array[0][1]\n    var east = array[0][2]\n    var north = array[0][3]\n\n    array.map(function (bbox) {\n      if (bbox[0] < west) { west = bbox[0] }\n      if (bbox[1] < south) { south = bbox[1] }\n      if (bbox[2] > east) { east = bbox[2] }\n      if (bbox[3] > north) { north = bbox[3] }\n    })\n    return [west, south, east, north]\n  }\n}\n\n/**\n * Valid TMS Tile\n *\n * @param {Tile} tile Tile [x, y, zoom]\n * @returns {boolean} valid tile true/false\n * @example\n * globalMercator.validTile([60, 80, 12])\n * //= true\n * globalMercator.validTile([60, -43, 5])\n * //= false\n * globalMercator.validTile([25, 60, 3])\n * //= false\n */\nfunction validTile (tile) {\n  try {\n    validateTile(tile)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * Modifies a Latitude to fit within +/-90 degrees.\n *\n * @param {number} lat latitude to modify\n * @returns {number} modified latitude\n * @example\n * globalMercator.latitude(100)\n * //= -80\n */\nfunction latitude (lat) {\n  if (lat === undefined || lat === null) throw new Error('lat is required')\n\n  // Latitudes cannot extends beyond +/-90 degrees\n  if (lat > 90 || lat < -90) {\n    lat = lat % 180\n    if (lat > 90) lat = -180 + lat\n    if (lat < -90) lat = 180 + lat\n    if (lat === 0) lat = 0\n  }\n  return lat\n}\n\n/**\n * Modifies a Longitude to fit within +/-180 degrees.\n *\n * @param {number} lng longitude to modify\n * @returns {number} modified longitude\n * @example\n * globalMercator.longitude(190)\n * //= -170\n */\nfunction longitude (lng) {\n  if (lng === undefined || lng === null) throw new Error('lng is required')\n\n  // lngitudes cannot extends beyond +/-90 degrees\n  if (lng > 180 || lng < -180) {\n    lng = lng % 360\n    if (lng > 180) lng = -360 + lng\n    if (lng < -180) lng = 360 + lng\n    if (lng === 0) lng = 0\n  }\n  return lng\n}\n\n/**\n * Get the smallest tile to cover a bbox\n *\n * @param {Array<number>} bbox BBox\n * @returns {Array<number>} tile Tile\n * @example\n * var tile = bboxToTile([-178, 84, -177, 85])\n * //=tile\n */\nfunction bboxToTile (bboxCoords) {\n  var min = pointToTile([bboxCoords[0], bboxCoords[1]], 32)\n  var max = pointToTile([bboxCoords[2], bboxCoords[3]], 32)\n  var bbox = [min[0], min[1], max[0], max[1]]\n\n  var z = getBboxZoom(bbox)\n  if (z === 0) return [0, 0, 0]\n  var x = bbox[0] >>> (32 - z)\n  var y = bbox[1] >>> (32 - z)\n  return [x, y, z]\n}\n\nfunction getBboxZoom (bbox) {\n  var MAX_ZOOM = 28\n  for (var z = 0; z < MAX_ZOOM; z++) {\n    var mask = 1 << (32 - (z + 1))\n    if (((bbox[0] & mask) !== (bbox[2] & mask)) ||\n      ((bbox[1] & mask) !== (bbox[3] & mask))) {\n      return z\n    }\n  }\n\n  return MAX_ZOOM\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsLW1lcmNhdG9yL2luZGV4LmpzPzBkZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IkRlUDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgb3JpZ2luU2hpZnQgPSAyICogTWF0aC5QSSAqIDYzNzgxMzcgLyAyLjBcbnZhciBkMnIgPSBNYXRoLlBJIC8gMTgwXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsUmVzb2x1dGlvbiAodGlsZVNpemUpIHtcbiAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCAyNTZcbiAgcmV0dXJuIDIgKiBNYXRoLlBJICogNjM3ODEzNyAvIHRpbGVTaXplXG59XG5cbi8qKlxuICogSGFzaCB0aWxlIGZvciB1bmlxdWUgaWQga2V5XG4gKlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFt4LCB5LCB6XVxuICogQHJldHVybnMge251bWJlcn0gaGFzaFxuICogQGV4YW1wbGVcbiAqIHZhciBpZCA9IGdsb2JhbE1lcmNhdG9yLmhhc2goWzMxMiwgNDgwLCA0XSlcbiAqIC8vPTU3MjhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2ggKHRpbGUpIHtcbiAgdmFyIHggPSB0aWxlWzBdXG4gIHZhciB5ID0gdGlsZVsxXVxuICB2YXIgeiA9IHRpbGVbMl1cbiAgcmV0dXJuICgxIDw8IHopICogKCgxIDw8IHopICsgeCkgKyB5XG59XG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIGZvciBhIHBvaW50IGF0IGEgc3BlY2lmaWVkIHpvb20gbGV2ZWxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvdGlsZWJlbHRcbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGxuZ2xhdCBbTG9uZ2l0dWRlLCBMYXRpdHVkZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBMYXRMbmcgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zIHtHb29nbGV9IEdvb2dsZSAoWFlaKSBUaWxlXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbGUgPSBnbG9iYWxNZXJjYXRvci5wb2ludFRvVGlsZShbMSwgMV0sIDEyKVxuICogLy89IFsgMjA1OSwgMjAzNiwgMTIgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1RpbGUgKGxuZ2xhdCwgem9vbSwgdmFsaWRhdGUpIHtcbiAgdmFyIHRpbGUgPSBwb2ludFRvVGlsZUZyYWN0aW9uKGxuZ2xhdCwgem9vbSwgdmFsaWRhdGUpXG4gIHRpbGVbMF0gPSBNYXRoLmZsb29yKHRpbGVbMF0pXG4gIHRpbGVbMV0gPSBNYXRoLmZsb29yKHRpbGVbMV0pXG4gIHJldHVybiB0aWxlXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVjaXNlIGZyYWN0aW9uYWwgdGlsZSBsb2NhdGlvbiBmb3IgYSBwb2ludCBhdCBhIHpvb20gbGV2ZWxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvdGlsZWJlbHRcbiAqXG4gKiBAbmFtZSBwb2ludFRvVGlsZUZyYWN0aW9uXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGxuZ2xhdCBbTG9uZ2l0dWRlLCBMYXRpdHVkZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBMYXRMbmcgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zIHtHb29nbGV9IEdvb2dsZSAoWFlaKSBUaWxlXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbGUgPSBnbG9iYWxNZXJjYXRvci5wb2ludFRvVGlsZUZyYWN0aW9uKFsxLCAxXSwgMTIpXG4gKiAvLz0gWyAyMDU5LjM3Nzc3Nzc3Nzc3NzcsIDIwMzYuNjIxNjQ0NTMzMzQzMiwgMTIgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1RpbGVGcmFjdGlvbiAobG5nbGF0LCB6b29tLCB2YWxpZGF0ZSkge1xuICAvLyBsbmdsYXQgPSB2YWxpZGF0ZUxuZ0xhdChsbmdsYXQsIHZhbGlkYXRlKVxuICB2YXIgeiA9IHpvb21cbiAgdmFyIGxvbiA9IGxvbmdpdHVkZShsbmdsYXRbMF0pXG4gIHZhciBsYXQgPSBsYXRpdHVkZShsbmdsYXRbMV0pXG4gIHZhciBzaW4gPSBNYXRoLnNpbihsYXQgKiBkMnIpXG4gIHZhciB6MiA9IE1hdGgucG93KDIsIHopXG4gIHZhciB4ID0gejIgKiAobG9uIC8gMzYwICsgMC41KVxuICB2YXIgeSA9IHoyICogKDAuNSAtIDAuMjUgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gTWF0aC5QSSlcbiAgcmV0dXJuIHZhbGlkYXRlVGlsZShbeCwgeSwgel0sIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIEJCb3ggdG8gQ2VudGVyXG4gKlxuICogQHBhcmFtIHtCQm94fSBiYm94IC0gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gY29vcmRpbmF0ZXNcbiAqIEByZXR1cm4ge0xuZ0xhdH0gY2VudGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGNlbnRlciA9IGdsb2JhbE1lcmNhdG9yLmJib3hUb0NlbnRlcihbOTAsIC00NSwgODUsIC01MF0pXG4gKiAvLz0gWyA4Ny41LCAtNDcuNSBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYm94VG9DZW50ZXIgKGJib3gpIHtcbiAgdmFyIHdlc3QgPSBiYm94WzBdXG4gIHZhciBzb3V0aCA9IGJib3hbMV1cbiAgdmFyIGVhc3QgPSBiYm94WzJdXG4gIHZhciBub3J0aCA9IGJib3hbM11cbiAgdmFyIGxuZyA9ICh3ZXN0IC0gZWFzdCkgLyAyICsgZWFzdFxuICB2YXIgbGF0ID0gKHNvdXRoIC0gbm9ydGgpIC8gMiArIG5vcnRoXG4gIGxuZyA9IE51bWJlcihsbmcudG9GaXhlZCg2KSlcbiAgbGF0ID0gTnVtYmVyKGxhdC50b0ZpeGVkKDYpKVxuICByZXR1cm4gW2xuZywgbGF0XVxufVxuXG4vKipcbiAqIENvbnZlcnRzIExuZ0xhdCBjb29yZGluYXRlcyB0byBNZXRlcnMgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBsbmdsYXQgW0xvbmdpdHVkZSwgTGF0aXR1ZGVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXSB2YWxpZGF0ZXMgTGF0TG5nIGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJucyB7TWV0ZXJzfSBNZXRlcnMgY29vcmRpbmF0ZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWV0ZXJzID0gZ2xvYmFsTWVyY2F0b3IubG5nTGF0VG9NZXRlcnMoWzEyNiwgMzddKVxuICogLy89WyAxNDAyNjI1NS44LCA0NDM5MTA2LjcgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9NZXRlcnMgKGxuZ2xhdCwgdmFsaWRhdGUpIHtcbiAgbG5nbGF0ID0gdmFsaWRhdGVMbmdMYXQobG5nbGF0LCB2YWxpZGF0ZSlcbiAgdmFyIGxuZyA9IGxuZ2xhdFswXVxuICB2YXIgbGF0ID0gbG5nbGF0WzFdXG4gIHZhciB4ID0gbG5nICogb3JpZ2luU2hpZnQgLyAxODAuMFxuICB2YXIgeSA9IE1hdGgubG9nKE1hdGgudGFuKCg5MCArIGxhdCkgKiBNYXRoLlBJIC8gMzYwLjApKSAvIChNYXRoLlBJIC8gMTgwLjApXG4gIHkgPSB5ICogb3JpZ2luU2hpZnQgLyAxODAuMFxuICB4ID0gTnVtYmVyKHgudG9GaXhlZCgxKSlcbiAgeSA9IE51bWJlcih5LnRvRml4ZWQoMSkpXG4gIHJldHVybiBbeCwgeV1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBNZXRlcnMgY29vcmRpbmF0ZXMgdG8gTG5nTGF0IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7TWV0ZXJzfSBtZXRlcnMgTWV0ZXJzIGluIE1lcmNhdG9yIFt4LCB5XVxuICogQHJldHVybnMge0xuZ0xhdH0gTG5nTGF0IGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxuZ2xhdCA9IGdsb2JhbE1lcmNhdG9yLm1ldGVyc1RvTG5nTGF0KFsxNDAyNjI1NSwgNDQzOTEwNl0pXG4gKiAvLz1bIDEyNiwgMzcgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWV0ZXJzVG9MbmdMYXQgKG1ldGVycykge1xuICB2YXIgeCA9IG1ldGVyc1swXVxuICB2YXIgeSA9IG1ldGVyc1sxXVxuICB2YXIgbG5nID0gKHggLyBvcmlnaW5TaGlmdCkgKiAxODAuMFxuICB2YXIgbGF0ID0gKHkgLyBvcmlnaW5TaGlmdCkgKiAxODAuMFxuICBsYXQgPSAxODAgLyBNYXRoLlBJICogKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAobGF0ICogTWF0aC5QSSAvIDE4MC4wKSkgLSBNYXRoLlBJIC8gMi4wKVxuICBsbmcgPSBOdW1iZXIobG5nLnRvRml4ZWQoNikpXG4gIGxhdCA9IE51bWJlcihsYXQudG9GaXhlZCg2KSlcbiAgcmV0dXJuIFtsbmcsIGxhdF1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBNZXRlcnMgY29vcmRpbmF0ZXMgdG8gUGl4ZWxzIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7TWV0ZXJzfSBtZXRlcnMgTWV0ZXJzIGluIE1lcmNhdG9yIFt4LCB5XVxuICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbFxuICogQHBhcmFtIHtudW1iZXJ9IFt0aWxlU2l6ZT0yNTZdIFRpbGUgc2l6ZVxuICogQHJldHVybnMge1BpeGVsc30gUGl4ZWxzIGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBpeGVscyA9IGdsb2JhbE1lcmNhdG9yLm1ldGVyc1RvUGl4ZWxzKFsxNDAyNjI1NSwgNDQzOTEwNl0sIDEzKVxuICogLy89WyAxNzgyNTc5LjEsIDEyODA4NzcuMywgMTMgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWV0ZXJzVG9QaXhlbHMgKG1ldGVycywgem9vbSwgdGlsZVNpemUpIHtcbiAgdmFyIHggPSBtZXRlcnNbMF1cbiAgdmFyIHkgPSBtZXRlcnNbMV1cbiAgdmFyIHJlcyA9IHJlc29sdXRpb24oem9vbSwgdGlsZVNpemUpXG4gIHZhciBweCA9ICh4ICsgb3JpZ2luU2hpZnQpIC8gcmVzXG4gIHZhciBweSA9ICh5ICsgb3JpZ2luU2hpZnQpIC8gcmVzXG4gIHJldHVybiBbcHgsIHB5LCB6b29tXVxufVxuXG4vKipcbiAqIENvbnZlcnRzIExuZ0xhdCBjb29yZGluYXRlcyB0byBUTVMgVGlsZS5cbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGxuZ2xhdCBbTG9uZ2l0dWRlLCBMYXRpdHVkZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBMYXRMbmcgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zIHtUaWxlfSBUTVMgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciB0aWxlID0gZ2xvYmFsTWVyY2F0b3IubG5nTGF0VG9UaWxlKFsxMjYsIDM3XSwgMTMpXG4gKiAvLz1bIDY5NjMsIDUwMDMsIDEzIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxuZ0xhdFRvVGlsZSAobG5nbGF0LCB6b29tLCB2YWxpZGF0ZSkge1xuICBsbmdsYXQgPSB2YWxpZGF0ZUxuZ0xhdChsbmdsYXQsIHZhbGlkYXRlKVxuICB2YXIgbWV0ZXJzID0gbG5nTGF0VG9NZXRlcnMobG5nbGF0KVxuICB2YXIgcGl4ZWxzID0gbWV0ZXJzVG9QaXhlbHMobWV0ZXJzLCB6b29tKVxuICByZXR1cm4gcGl4ZWxzVG9UaWxlKHBpeGVscylcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBMbmdMYXQgY29vcmRpbmF0ZXMgdG8gR29vZ2xlIChYWVopIFRpbGUuXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBsbmdsYXQgW0xvbmdpdHVkZSwgTGF0aXR1ZGVdXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXSB2YWxpZGF0ZXMgTGF0TG5nIGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJucyB7R29vZ2xlfSBHb29nbGUgKFhZWikgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciBnb29nbGUgPSBnbG9iYWxNZXJjYXRvci5sbmdMYXRUb0dvb2dsZShbMTI2LCAzN10sIDEzKVxuICogLy89WyA2OTYzLCAzMTg4LCAxMyBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsbmdMYXRUb0dvb2dsZSAobG5nbGF0LCB6b29tLCB2YWxpZGF0ZSkge1xuICBsbmdsYXQgPSB2YWxpZGF0ZUxuZ0xhdChsbmdsYXQsIHZhbGlkYXRlKVxuXG4gIGlmICh6b29tID09PSAwKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXVxuICB9XG4gIHZhciB0aWxlID0gbG5nTGF0VG9UaWxlKGxuZ2xhdCwgem9vbSlcbiAgcmV0dXJuIHRpbGVUb0dvb2dsZSh0aWxlKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIE1ldGVycyBjb29yZGluYXRlcyB0byBUTVMgVGlsZS5cbiAqXG4gKiBAcGFyYW0ge01ldGVyc30gbWV0ZXJzIE1ldGVycyBpbiBNZXJjYXRvciBbeCwgeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEByZXR1cm5zIHtUaWxlfSBUTVMgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciB0aWxlID0gZ2xvYmFsTWVyY2F0b3IubWV0ZXJzVG9UaWxlKFsxNDAyNjI1NSwgNDQzOTEwNl0sIDEzKVxuICogLy89WyA2OTYzLCA1MDAzLCAxMyBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXRlcnNUb1RpbGUgKG1ldGVycywgem9vbSkge1xuICBpZiAoem9vbSA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMCwgMF1cbiAgfVxuICB2YXIgcGl4ZWxzID0gbWV0ZXJzVG9QaXhlbHMobWV0ZXJzLCB6b29tKVxuICByZXR1cm4gcGl4ZWxzVG9UaWxlKHBpeGVscylcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBQaXhlbHMgY29vcmRpbmF0ZXMgdG8gTWV0ZXJzIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7UGl4ZWxzfSBwaXhlbHMgUGl4ZWxzIFt4LCB5LCB6b29tXVxuICogQHBhcmFtIHtudW1iZXJ9IFt0aWxlU2l6ZT0yNTZdIFRpbGUgc2l6ZVxuICogQHJldHVybnMge01ldGVyc30gTWV0ZXJzIGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIG1ldGVycyA9IGdsb2JhbE1lcmNhdG9yLnBpeGVsc1RvTWV0ZXJzKFsxNzgyNTc5LCAxMjgwODc3LCAxM10pXG4gKiAvLz1bIDE0MDI2MjUyLjAsIDQ0MzkwOTkuNSBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXhlbHNUb01ldGVycyAocGl4ZWxzLCB0aWxlU2l6ZSkge1xuICB2YXIgcHggPSBwaXhlbHNbMF1cbiAgdmFyIHB5ID0gcGl4ZWxzWzFdXG4gIHZhciB6b29tID0gcGl4ZWxzWzJdXG4gIHZhciByZXMgPSByZXNvbHV0aW9uKHpvb20sIHRpbGVTaXplKVxuICB2YXIgbXggPSBweCAqIHJlcyAtIG9yaWdpblNoaWZ0XG4gIHZhciBteSA9IHB5ICogcmVzIC0gb3JpZ2luU2hpZnRcbiAgbXggPSBOdW1iZXIobXgudG9GaXhlZCgxKSlcbiAgbXkgPSBOdW1iZXIobXkudG9GaXhlZCgxKSlcbiAgcmV0dXJuIFtteCwgbXldXG59XG5cbi8qKlxuICogQ29udmVydHMgUGl4ZWxzIGNvb3JkaW5hdGVzIHRvIFRNUyBUaWxlLlxuICpcbiAqIEBwYXJhbSB7UGl4ZWxzfSBwaXhlbHMgUGl4ZWxzIFt4LCB5LCB6b29tXVxuICogQHBhcmFtIHtudW1iZXJ9IFt0aWxlU2l6ZT0yNTZdIFRpbGUgc2l6ZVxuICogQHBhcmFtIHtib29sZWFufSBbdmFsaWRhdGU9dHJ1ZV0gdmFsaWRhdGVzIFBpeGVscyBjb29yZGluYXRlc1xuICogQHJldHVybnMge1RpbGV9IFRNUyBUaWxlXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbGUgPSBnbG9iYWxNZXJjYXRvci5waXhlbHNUb1RpbGUoWzE3ODI1NzksIDEyODA4NzcsIDEzXSlcbiAqIC8vPVsgNjk2MywgNTAwMywgMTMgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9UaWxlIChwaXhlbHMsIHRpbGVTaXplLCB2YWxpZGF0ZSkge1xuICB0aWxlU2l6ZSA9IHRpbGVTaXplIHx8IDI1NlxuICB2YXIgcHggPSBwaXhlbHNbMF1cbiAgdmFyIHB5ID0gcGl4ZWxzWzFdXG4gIHZhciB6b29tID0gcGl4ZWxzWzJdXG4gIGlmICh6b29tID09PSAwKSByZXR1cm4gWzAsIDAsIDBdXG5cbiAgdmFsaWRhdGVab29tKHpvb20sIHZhbGlkYXRlKVxuICB2YXIgdHggPSBNYXRoLmNlaWwocHggLyB0aWxlU2l6ZSkgLSAxXG4gIHZhciB0eSA9IE1hdGguY2VpbChweSAvIHRpbGVTaXplKSAtIDFcbiAgaWYgKHR4IDwgMCkgdHggPSAwXG4gIGlmICh0eSA8IDApIHR5ID0gMFxuICByZXR1cm4gW3R4LCB0eSwgem9vbV1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBUTVMgVGlsZSB0byBiYm94IGluIE1ldGVycyBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGlsZSBbeCwgeSwgem9vbV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRNUyBUaWxlIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRNUyBUaWxlIFlcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGlsZVNpemU9MjU2XSBUaWxlIHNpemVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBUaWxlXG4gKiBAcmV0dXJucyB7QkJveH0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBnbG9iYWxNZXJjYXRvci50aWxlVG9CQm94TWV0ZXJzKFs2OTYzLCA1MDAzLCAxM10pXG4gKiAvLz1bIDE0MDI1Mjc3LjQsIDQ0MzcwMTYuNiwgMTQwMzAxNjkuNCwgNDQ0MTkwOC41IF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbGVUb0JCb3hNZXRlcnMgKHRpbGUsIHRpbGVTaXplLCB2YWxpZGF0ZSkge1xuICB2YWxpZGF0ZVRpbGUodGlsZSwgdmFsaWRhdGUpXG5cbiAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCAyNTZcbiAgdmFyIHR4ID0gdGlsZVswXVxuICB2YXIgdHkgPSB0aWxlWzFdXG4gIHZhciB6b29tID0gdGlsZVsyXVxuICB2YXIgbWluID0gcGl4ZWxzVG9NZXRlcnMoW3R4ICogdGlsZVNpemUsIHR5ICogdGlsZVNpemUsIHpvb21dKVxuICB2YXIgbWF4ID0gcGl4ZWxzVG9NZXRlcnMoWyh0eCArIDEpICogdGlsZVNpemUsICh0eSArIDEpICogdGlsZVNpemUsIHpvb21dKVxuICByZXR1cm4gW21pblswXSwgbWluWzFdLCBtYXhbMF0sIG1heFsxXV1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBUTVMgVGlsZSB0byBiYm94IGluIExuZ0xhdCBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGlsZSBbeCwgeSwgem9vbV1cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRNUyBUaWxlIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRNUyBUaWxlIFlcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBUaWxlXG4gKiBAcmV0dXJucyB7QkJveH0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBnbG9iYWxNZXJjYXRvci50aWxlVG9CQm94KFs2OTYzLCA1MDAzLCAxM10pXG4gKiAvLz1bIDEyNS45OTEsIDM2Ljk4NSwgMTI2LjAzNSwgMzcuMDIwIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbGVUb0JCb3ggKHRpbGUsIHZhbGlkYXRlKSB7XG4gIHZhbGlkYXRlVGlsZSh0aWxlLCB2YWxpZGF0ZSlcblxuICB2YXIgdHggPSB0aWxlWzBdXG4gIHZhciB0eSA9IHRpbGVbMV1cbiAgdmFyIHpvb20gPSB0aWxlWzJdXG4gIGlmICh6b29tID09PSAwKSB7XG4gICAgcmV0dXJuIFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgfVxuICB2YXIgYmJveCA9IHRpbGVUb0JCb3hNZXRlcnMoW3R4LCB0eSwgem9vbV0pXG4gIHZhciBteDEgPSBiYm94WzBdXG4gIHZhciBteTEgPSBiYm94WzFdXG4gIHZhciBteDIgPSBiYm94WzJdXG4gIHZhciBteTIgPSBiYm94WzNdXG4gIHZhciBtaW4gPSBtZXRlcnNUb0xuZ0xhdChbbXgxLCBteTEsIHpvb21dKVxuICB2YXIgbWF4ID0gbWV0ZXJzVG9MbmdMYXQoW214MiwgbXkyLCB6b29tXSlcbiAgcmV0dXJuIFttaW5bMF0sIG1pblsxXSwgbWF4WzBdLCBtYXhbMV1dXG59XG5cbi8qKlxuICogQ29udmVydHMgR29vZ2xlIChYWVopIFRpbGUgdG8gYmJveCBpbiBNZXRlcnMgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtHb29nbGV9IGdvb2dsZSBHb29nbGUgW3gsIHksIHpvb21dXG4gKiBAcmV0dXJucyB7QkJveH0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBnbG9iYWxNZXJjYXRvci5nb29nbGVUb0JCb3hNZXRlcnMoWzY5NjMsIDMxODgsIDEzXSlcbiAqIC8vPVsgMTQwMjUyNzcuNCwgNDQzNzAxNi42LCAxNDAzMDE2OS40LCA0NDQxOTA4LjUgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ29vZ2xlVG9CQm94TWV0ZXJzIChnb29nbGUpIHtcbiAgdmFyIFRpbGUgPSBnb29nbGVUb1RpbGUoZ29vZ2xlKVxuICByZXR1cm4gdGlsZVRvQkJveE1ldGVycyhUaWxlKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIEdvb2dsZSAoWFlaKSBUaWxlIHRvIGJib3ggaW4gTG5nTGF0IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7R29vZ2xlfSBnb29nbGUgR29vZ2xlIFt4LCB5LCB6b29tXVxuICogQHJldHVybnMge0JCb3h9IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gZ2xvYmFsTWVyY2F0b3IuZ29vZ2xlVG9CQm94KFs2OTYzLCAzMTg4LCAxM10pXG4gKiAvLz1bIDEyNS45OTEsIDM2Ljk4NSwgMTI2LjAzNSwgMzcuMDIwIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdvb2dsZVRvQkJveCAoZ29vZ2xlKSB7XG4gIHZhciBUaWxlID0gZ29vZ2xlVG9UaWxlKGdvb2dsZSlcbiAgcmV0dXJuIHRpbGVUb0JCb3goVGlsZSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBUTVMgVGlsZSB0byBHb29nbGUgKFhZWikgVGlsZS5cbiAqXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGlsZSBbeCwgeSwgem9vbV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlPXRydWVdIHZhbGlkYXRlcyBUaWxlXG4gKiBAcmV0dXJucyB7R29vZ2xlfSBHb29nbGUgKFhZWikgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciBnb29nbGUgPSBnbG9iYWxNZXJjYXRvci50aWxlVG9Hb29nbGUoWzY5NjMsIDUwMDMsIDEzXSlcbiAqIC8vPVsgNjk2MywgMzE4OCwgMTMgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGlsZVRvR29vZ2xlICh0aWxlLCB2YWxpZGF0ZSkge1xuICB2YWxpZGF0ZVRpbGUodGlsZSwgdmFsaWRhdGUpXG5cbiAgdmFyIHR4ID0gdGlsZVswXVxuICB2YXIgdHkgPSB0aWxlWzFdXG4gIHZhciB6b29tID0gdGlsZVsyXVxuICBpZiAoem9vbSA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMCwgMF1cbiAgfVxuICB2YXIgeCA9IHR4XG4gIHZhciB5ID0gKE1hdGgucG93KDIsIHpvb20pIC0gMSkgLSB0eVxuICByZXR1cm4gW3gsIHksIHpvb21dXG59XG5cbi8qKlxuICogQ29udmVydHMgR29vZ2xlIChYWVopIFRpbGUgdG8gVE1TIFRpbGUuXG4gKlxuICogQHBhcmFtIHtHb29nbGV9IGdvb2dsZSBHb29nbGUgW3gsIHksIHpvb21dXG4gKiBAcmV0dXJucyB7VGlsZX0gVE1TIFRpbGVcbiAqIEBleGFtcGxlXG4gKiB2YXIgdGlsZSA9IGdsb2JhbE1lcmNhdG9yLmdvb2dsZVRvVGlsZShbNjk2MywgMzE4OCwgMTNdKVxuICogLy89WyA2OTYzLCA1MDAzLCAxMyBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnb29nbGVUb1RpbGUgKGdvb2dsZSkge1xuICB2YXIgeCA9IGdvb2dsZVswXVxuICB2YXIgeSA9IGdvb2dsZVsxXVxuICB2YXIgem9vbSA9IGdvb2dsZVsyXVxuICB2YXIgdHggPSB4XG4gIHZhciB0eSA9IE1hdGgucG93KDIsIHpvb20pIC0geSAtIDFcbiAgcmV0dXJuIFt0eCwgdHksIHpvb21dXG59XG5cbi8qKlxuICogQ29udmVydHMgR29vZ2xlIChYWVopIFRpbGUgdG8gUXVhZGtleS5cbiAqXG4gKiBAcGFyYW0ge0dvb2dsZX0gZ29vZ2xlIEdvb2dsZSBbeCwgeSwgem9vbV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IE1pY3Jvc29mdCdzIFF1YWRrZXkgc2NoZW1hXG4gKiBAZXhhbXBsZVxuICogdmFyIHF1YWRrZXkgPSBnbG9iYWxNZXJjYXRvci5nb29nbGVUb1F1YWRrZXkoWzY5NjMsIDMxODgsIDEzXSlcbiAqIC8vPScxMzIxMTAyMzMwMjExJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ29vZ2xlVG9RdWFka2V5IChnb29nbGUpIHtcbiAgdmFyIFRpbGUgPSBnb29nbGVUb1RpbGUoZ29vZ2xlKVxuICByZXR1cm4gdGlsZVRvUXVhZGtleShUaWxlKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIFRNUyBUaWxlIHRvIFF1YWRLZXkuXG4gKlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRpbGUgW3gsIHksIHpvb21dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXSB2YWxpZGF0ZXMgVGlsZVxuICogQHJldHVybnMge3N0cmluZ30gTWljcm9zb2Z0J3MgUXVhZGtleSBzY2hlbWFcbiAqIEBleGFtcGxlXG4gKiB2YXIgcXVhZGtleSA9IGdsb2JhbE1lcmNhdG9yLnRpbGVUb1F1YWRrZXkoWzY5NjMsIDUwMDMsIDEzXSlcbiAqIC8vPScxMzIxMTAyMzMwMjExJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGlsZVRvUXVhZGtleSAodGlsZSwgdmFsaWRhdGUpIHtcbiAgdmFsaWRhdGVUaWxlKHRpbGUsIHZhbGlkYXRlKVxuXG4gIHZhciB0eCA9IHRpbGVbMF1cbiAgdmFyIHR5ID0gdGlsZVsxXVxuICB2YXIgem9vbSA9IHRpbGVbMl1cbiAgLy8gWm9vbSAwIGRvZXMgbm90IGV4aXN0IGZvciBRdWFka2V5XG4gIGlmICh6b29tID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgdmFyIHF1YWRrZXkgPSAnJ1xuICB0eSA9IChNYXRoLnBvdygyLCB6b29tKSAtIDEpIC0gdHlcbiAgcmFuZ2Uoem9vbSwgMCwgLTEpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHZhciBkaWdpdCA9IDBcbiAgICB2YXIgbWFzayA9IDEgPDwgKGkgLSAxKVxuICAgIGlmICgodHggJiBtYXNrKSAhPT0gMCkge1xuICAgICAgZGlnaXQgKz0gMVxuICAgIH1cbiAgICBpZiAoKHR5ICYgbWFzaykgIT09IDApIHtcbiAgICAgIGRpZ2l0ICs9IDJcbiAgICB9XG4gICAgcXVhZGtleSA9IHF1YWRrZXkuY29uY2F0KGRpZ2l0KVxuICB9KVxuICByZXR1cm4gcXVhZGtleVxufVxuXG4vKipcbiAqIENvbnZlcnRzIFF1YWRrZXkgdG8gVE1TIFRpbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHF1YWRrZXkgTWljcm9zb2Z0J3MgUXVhZGtleSBzY2hlbWFcbiAqIEByZXR1cm5zIHtUaWxlfSBUTVMgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciB0aWxlID0gZ2xvYmFsTWVyY2F0b3IucXVhZGtleVRvVGlsZSgnMTMyMTEwMjMzMDIxMScpXG4gKiAvLz1bIDY5NjMsIDUwMDMsIDEzIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRrZXlUb1RpbGUgKHF1YWRrZXkpIHtcbiAgdmFyIEdvb2dsZSA9IHF1YWRrZXlUb0dvb2dsZShxdWFka2V5KVxuICByZXR1cm4gZ29vZ2xlVG9UaWxlKEdvb2dsZSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBRdWFka2V5IHRvIEdvb2dsZSAoWFlaKSBUaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWFka2V5IE1pY3Jvc29mdCdzIFF1YWRrZXkgc2NoZW1hXG4gKiBAcmV0dXJucyB7R29vZ2xlfSBHb29nbGUgKFhZWikgVGlsZVxuICogQGV4YW1wbGVcbiAqIHZhciBnb29nbGUgPSBnbG9iYWxNZXJjYXRvci5xdWFka2V5VG9Hb29nbGUoJzEzMjExMDIzMzAyMTEnKVxuICogLy89WyA2OTYzLCAzMTg4LCAxMyBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFka2V5VG9Hb29nbGUgKHF1YWRrZXkpIHtcbiAgdmFyIHggPSAwXG4gIHZhciB5ID0gMFxuICB2YXIgem9vbSA9IHF1YWRrZXkubGVuZ3RoXG4gIHJhbmdlKHpvb20sIDAsIC0xKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgbWFzayA9IDEgPDwgKGkgLSAxKVxuICAgIHN3aXRjaCAocGFyc2VJbnQocXVhZGtleVt6b29tIC0gaV0sIDApKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHggKz0gbWFza1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICB5ICs9IG1hc2tcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCArPSBtYXNrXG4gICAgICAgIHkgKz0gbWFza1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFF1YWRrZXkgZGlnaXQgc2VxdWVuY2UnKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIFt4LCB5LCB6b29tXVxufVxuXG4vKipcbiAqIENvbnZlcnRzIEJCb3ggZnJvbSBMbmdMYXQgY29vcmRpbmF0ZXMgdG8gTWV0ZXJzIGNvb3JkaW5hdGVzXG4gKlxuICogQHBhcmFtIHtCQm94fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEByZXR1cm5zIHtCQm94fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWV0ZXJzID0gZ2xvYmFsTWVyY2F0b3IuYmJveFRvTWV0ZXJzKFsgMTI1LCAzNSwgMTI3LCAzNyBdKVxuICogLy89WyAxMzkxNDkzNi4zLCA0MTYzODgxLjEsIDE0MTM3NTc1LjMsIDQ0MzkxMDYuNyBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYm94VG9NZXRlcnMgKGJib3gpIHtcbiAgdmFyIG1pbiA9IGxuZ0xhdFRvTWV0ZXJzKFtiYm94WzBdLCBiYm94WzFdXSlcbiAgdmFyIG1heCA9IGxuZ0xhdFRvTWV0ZXJzKFtiYm94WzJdLCBiYm94WzNdXSlcbiAgcmV0dXJuIFttaW5bMF0sIG1pblsxXSwgbWF4WzBdLCBtYXhbMV1dXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIFRNUyBUaWxlLlxuICpcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaWxlIFt4LCB5LCB6b29tXVxuICogQHBhcmFtIHtib29sZWFufSBbdmFsaWRhdGU9dHJ1ZV0gdmFsaWRhdGVzIFRpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGFuIGVycm9yIGlmIFRNUyBUaWxlIGlzIG5vdCB2YWxpZC5cbiAqIEByZXR1cm5zIHtUaWxlfSBUTVMgVGlsZVxuICogQGV4YW1wbGVcbiAqIGdsb2JhbE1lcmNhdG9yLnZhbGlkYXRlVGlsZShbNjAsIDgwLCAxMl0pXG4gKiAvLz1bNjAsIDgwLCAxMl1cbiAqIGdsb2JhbE1lcmNhdG9yLnZhbGlkYXRlVGlsZShbNjAsIC00MywgNV0pXG4gKiAvLz0gRXJyb3I6IFRpbGUgPHk+IG11c3Qgbm90IGJlIGxlc3MgdGhhbiAwXG4gKiBnbG9iYWxNZXJjYXRvci52YWxpZGF0ZVRpbGUoWzI1LCA2MCwgM10pXG4gKiAvLz0gRXJyb3I6IElsbGVnYWwgcGFyYW1ldGVycyBmb3IgdGlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUaWxlICh0aWxlLCB2YWxpZGF0ZSkge1xuICB2YXIgdHggPSB0aWxlWzBdXG4gIHZhciB0eSA9IHRpbGVbMV1cbiAgdmFyIHpvb20gPSB0aWxlWzJdXG4gIGlmICh2YWxpZGF0ZSA9PT0gZmFsc2UpIHJldHVybiB0aWxlXG4gIGlmICh6b29tID09PSB1bmRlZmluZWQgfHwgem9vbSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCc8em9vbT4gaXMgcmVxdWlyZWQnKVxuICBpZiAodHggPT09IHVuZGVmaW5lZCB8fCB0eCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCc8eD4gaXMgcmVxdWlyZWQnKVxuICBpZiAodHkgPT09IHVuZGVmaW5lZCB8fCB0eSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCc8eT4gaXMgcmVxdWlyZWQnKVxuXG4gIC8vIEFkanVzdCB2YWx1ZXMgb2YgdGlsZXMgdG8gZml0IHdpdGhpbiB0aWxlIHNjaGVtZVxuICB6b29tID0gdmFsaWRhdGVab29tKHpvb20pXG4gIHRpbGUgPSB3cmFwVGlsZSh0aWxlKVxuXG4gIC8vIC8vIENoZWNrIHRvIHNlZSBpZiB0aWxlIGlzIHZhbGlkIGJhc2VkIG9uIHRoZSB6b29tIGxldmVsXG4gIC8vIC8vIEN1cnJlbnRseSBpbXBvc3NpYmxlIHRvIGhpdCBzaW5jZSBXcmFwVGlsZSBoYW5kbGVzIHRoaXMgZXJyb3JcbiAgLy8gLy8gd2lsbCBrZWVwIHRoaXMgdGVzdCBjb21tZW50ZWQgb3V0IGluIGNhc2UgaXQgZG9lc250IGhhbmRsZSBpdFxuICAvLyB2YXIgbWF4Q291bnQgPSBNYXRoLnBvdygyLCB6b29tKVxuICAvLyBpZiAodGlsZVswXSA+PSBtYXhDb3VudCB8fCB0aWxlWzFdID49IG1heENvdW50KSB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGFyYW1ldGVycyBmb3IgdGlsZScpXG4gIHJldHVybiB0aWxlXG59XG5cbi8qKlxuICogV3JhcCBUaWxlIC0tIEhhbmRsZXMgdGlsZXMgd2hpY2ggY3Jvc3NlcyB0aGUgMTgwdGggbWVyaWRpYW4gb3IgOTB0aCBwYXJhbGxlbFxuICpcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyLCBudW1iZXJdfSB0aWxlIFRpbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gTGV2ZWxcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IFdyYXBwZWQgVGlsZVxuICogQGV4YW1wbGVcbiAqIGdsb2JhbE1lcmNhdG9yLndyYXBUaWxlKFswLCAzLCAyXSlcbiAqIC8vPSBbMCwgMywgMl0gLS0gVmFsaWQgVGlsZSBYXG4gKiBnbG9iYWxNZXJjYXRvci53cmFwVGlsZShbNCwgMiwgMl0pXG4gKiAvLz0gWzAsIDIsIDJdIC0tIFRpbGUgNCBkb2VzIG5vdCBleGlzdCwgd3JhcCBhcm91bmQgdG8gVGlsZVg9MFxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFRpbGUgKHRpbGUpIHtcbiAgdmFyIHR4ID0gdGlsZVswXVxuICB2YXIgdHkgPSB0aWxlWzFdXG4gIHZhciB6b29tID0gdGlsZVsyXVxuXG4gIC8vIE1heGltdW0gdGlsZSBhbGxvd2VkXG4gIC8vIHpvb20gMCA9PiAxXG4gIC8vIHpvb20gMSA9PiAyXG4gIC8vIHpvb20gMiA9PiA0XG4gIC8vIHpvb20gMyA9PiA4XG4gIHZhciBtYXhUaWxlID0gTWF0aC5wb3coMiwgem9vbSlcblxuICAvLyBIYW5kbGUgVGlsZSBYXG4gIHR4ID0gdHggJSBtYXhUaWxlXG4gIGlmICh0eCA8IDApIHR4ID0gdHggKyBtYXhUaWxlXG5cbiAgcmV0dXJuIFt0eCwgdHksIHpvb21dXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIFpvb20gbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXSB2YWxpZGF0ZXMgWm9vbSBsZXZlbFxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgem9vbSBpcyBub3QgdmFsaWQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWxcbiAqIEBleGFtcGxlXG4gKiBnbG9iYWxNZXJjYXRvci52YWxpZGF0ZVpvb20oMTIpXG4gKiAvLz0xMlxuICogZ2xvYmFsTWVyY2F0b3IudmFsaWRhdGVab29tKC00KVxuICogLy89IEVycm9yOiA8em9vbT4gY2Fubm90IGJlIGxlc3MgdGhhbiAwXG4gKiBnbG9iYWxNZXJjYXRvci52YWxpZGF0ZVpvb20oMzIpXG4gKiAvLz0gRXJyb3I6IDx6b29tPiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDMwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVpvb20gKHpvb20pIHtcbiAgaWYgKHpvb20gPT09IGZhbHNlKSByZXR1cm4gem9vbVxuICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkIHx8IHpvb20gPT09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKCc8em9vbT4gaXMgcmVxdWlyZWQnKSB9XG4gIGlmICh6b29tIDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoJzx6b29tPiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnKSB9XG4gIGlmICh6b29tID4gMzIpIHsgdGhyb3cgbmV3IEVycm9yKCc8em9vbT4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAzMicpIH1cbiAgcmV0dXJuIHpvb21cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgTG5nTGF0IGNvb3JkaW5hdGVzXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBsbmdsYXQgW0xvbmdpdHVkZSwgTGF0aXR1ZGVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXSB2YWxpZGF0ZXMgTGF0TG5nIGNvb3JkaW5hdGVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBMbmdMYXQgaXMgbm90IHZhbGlkLlxuICogQHJldHVybnMge0xuZ0xhdH0gTG5nTGF0IGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogZ2xvYmFsTWVyY2F0b3IudmFsaWRhdGVMbmdMYXQoWy0xMTUsIDQ0XSlcbiAqIC8vPSBbIC0xMTUsIDQ0IF1cbiAqIGdsb2JhbE1lcmNhdG9yLnZhbGlkYXRlTG5nTGF0KFstMjI1LCA0NF0pXG4gKiAvLz0gRXJyb3I6IExuZ0xhdCBbbG5nXSBtdXN0IGJlIHdpdGhpbiAtMTgwIHRvIDE4MCBkZWdyZWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxuZ0xhdCAobG5nbGF0LCB2YWxpZGF0ZSkge1xuICBpZiAodmFsaWRhdGUgPT09IGZhbHNlKSByZXR1cm4gbG5nbGF0XG5cbiAgdmFyIGxuZyA9IGxvbmdpdHVkZShsbmdsYXRbMF0pXG4gIHZhciBsYXQgPSBsYXRpdHVkZShsbmdsYXRbMV0pXG5cbiAgLy8gR2xvYmFsIE1lcmNhdG9yIGRvZXMgbm90IHN1cHBvcnQgbGF0aXR1ZGVzIHdpdGhpbiA4NSB0byA5MCBkZWdyZWVzXG4gIGlmIChsYXQgPiA4NSkgbGF0ID0gODVcbiAgaWYgKGxhdCA8IC04NSkgbGF0ID0gLTg1XG4gIHJldHVybiBbbG5nLCBsYXRdXG59XG5cbi8qKlxuICogUmV0cmlldmUgcmVzb2x1dGlvbiBiYXNlZCBvbiB6b29tIGxldmVsXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIHpvb20gbGV2ZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGlsZVNpemU9MjU2XSBUaWxlIHNpemVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc29sdXRpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVzID0gZ2xvYmFsTWVyY2F0b3IucmVzb2x1dGlvbigxMylcbiAqIC8vPTE5LjEwOTI1NzA3MTI5NDA2M1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x1dGlvbiAoem9vbSwgdGlsZVNpemUpIHtcbiAgcmV0dXJuIGluaXRpYWxSZXNvbHV0aW9uKHRpbGVTaXplKSAvIE1hdGgucG93KDIsIHpvb20pXG59XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gU3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wIFN0b3BcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBTdGVwXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHJhbmdlXG4gKiBAZXhhbXBsZVxuICogZ2xvYmFsTWVyY2F0b3IucmFuZ2UoMylcbiAqIC8vPVsgMCwgMSwgMiBdXG4gKiBnbG9iYWxNZXJjYXRvci5yYW5nZSgzLCA2KVxuICogLy89WyAzLCA0LCA1IF1cbiAqIGdsb2JhbE1lcmNhdG9yLnJhbmdlKDYsIDMsIC0xKVxuICogLy89WyA2LCA1LCA0IF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlIChzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgc3RvcCA9IHN0YXJ0IHx8IDBcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoIXN0ZXApIHtcbiAgICBzdGVwID0gc3RvcCA8IHN0YXJ0ID8gLTEgOiAxXG4gIH1cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKVxuICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICByYW5nZVtpZHhdID0gc3RhcnRcbiAgfVxuICByZXR1cm4gcmFuZ2Vcbn1cblxuLyoqXG4gKiBNYXhpbXVtIGV4dGVudCBvZiBCQm94XG4gKlxuICogQHBhcmFtIHtCQm94fEJCb3hbXX0gYXJyYXkgQkJveCBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogQHJldHVybnMge0JCb3h9IE1heGltdW0gQkJveFxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gZ2xvYmFsTWVyY2F0b3IubWF4QkJveChbWy0yMCwgLTMwLCAyMCwgMzBdLCBbLTExMCwgLTMwLCAxMjAsIDgwXV0pXG4gKiAvLz1bLTExMCwgLTMwLCAxMjAsIDgwXVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4QkJveCAoYXJyYXkpIHtcbiAgaWYgKCFhcnJheSkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBpcyByZXF1aXJlZCcpXG5cbiAgLy8gU2luZ2xlIEJCb3hcbiAgaWYgKGFycmF5ICYmIGFycmF5WzBdICYmIGFycmF5Lmxlbmd0aCA9PT0gNCAmJiBhcnJheVswXVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFycmF5XG4gIH1cblxuICAvLyBNdWx0aXBsZSBCQm94XG4gIGlmIChhcnJheSAmJiBhcnJheVswXSAmJiBhcnJheVswXVswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHdlc3QgPSBhcnJheVswXVswXVxuICAgIHZhciBzb3V0aCA9IGFycmF5WzBdWzFdXG4gICAgdmFyIGVhc3QgPSBhcnJheVswXVsyXVxuICAgIHZhciBub3J0aCA9IGFycmF5WzBdWzNdXG5cbiAgICBhcnJheS5tYXAoZnVuY3Rpb24gKGJib3gpIHtcbiAgICAgIGlmIChiYm94WzBdIDwgd2VzdCkgeyB3ZXN0ID0gYmJveFswXSB9XG4gICAgICBpZiAoYmJveFsxXSA8IHNvdXRoKSB7IHNvdXRoID0gYmJveFsxXSB9XG4gICAgICBpZiAoYmJveFsyXSA+IGVhc3QpIHsgZWFzdCA9IGJib3hbMl0gfVxuICAgICAgaWYgKGJib3hbM10gPiBub3J0aCkgeyBub3J0aCA9IGJib3hbM10gfVxuICAgIH0pXG4gICAgcmV0dXJuIFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZCBUTVMgVGlsZVxuICpcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaWxlIFt4LCB5LCB6b29tXVxuICogQHJldHVybnMge2Jvb2xlYW59IHZhbGlkIHRpbGUgdHJ1ZS9mYWxzZVxuICogQGV4YW1wbGVcbiAqIGdsb2JhbE1lcmNhdG9yLnZhbGlkVGlsZShbNjAsIDgwLCAxMl0pXG4gKiAvLz0gdHJ1ZVxuICogZ2xvYmFsTWVyY2F0b3IudmFsaWRUaWxlKFs2MCwgLTQzLCA1XSlcbiAqIC8vPSBmYWxzZVxuICogZ2xvYmFsTWVyY2F0b3IudmFsaWRUaWxlKFsyNSwgNjAsIDNdKVxuICogLy89IGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFRpbGUgKHRpbGUpIHtcbiAgdHJ5IHtcbiAgICB2YWxpZGF0ZVRpbGUodGlsZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBNb2RpZmllcyBhIExhdGl0dWRlIHRvIGZpdCB3aXRoaW4gKy8tOTAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IGxhdGl0dWRlIHRvIG1vZGlmeVxuICogQHJldHVybnMge251bWJlcn0gbW9kaWZpZWQgbGF0aXR1ZGVcbiAqIEBleGFtcGxlXG4gKiBnbG9iYWxNZXJjYXRvci5sYXRpdHVkZSgxMDApXG4gKiAvLz0gLTgwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXRpdHVkZSAobGF0KSB7XG4gIGlmIChsYXQgPT09IHVuZGVmaW5lZCB8fCBsYXQgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignbGF0IGlzIHJlcXVpcmVkJylcblxuICAvLyBMYXRpdHVkZXMgY2Fubm90IGV4dGVuZHMgYmV5b25kICsvLTkwIGRlZ3JlZXNcbiAgaWYgKGxhdCA+IDkwIHx8IGxhdCA8IC05MCkge1xuICAgIGxhdCA9IGxhdCAlIDE4MFxuICAgIGlmIChsYXQgPiA5MCkgbGF0ID0gLTE4MCArIGxhdFxuICAgIGlmIChsYXQgPCAtOTApIGxhdCA9IDE4MCArIGxhdFxuICAgIGlmIChsYXQgPT09IDApIGxhdCA9IDBcbiAgfVxuICByZXR1cm4gbGF0XG59XG5cbi8qKlxuICogTW9kaWZpZXMgYSBMb25naXR1ZGUgdG8gZml0IHdpdGhpbiArLy0xODAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG5nIGxvbmdpdHVkZSB0byBtb2RpZnlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1vZGlmaWVkIGxvbmdpdHVkZVxuICogQGV4YW1wbGVcbiAqIGdsb2JhbE1lcmNhdG9yLmxvbmdpdHVkZSgxOTApXG4gKiAvLz0gLTE3MFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9uZ2l0dWRlIChsbmcpIHtcbiAgaWYgKGxuZyA9PT0gdW5kZWZpbmVkIHx8IGxuZyA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdsbmcgaXMgcmVxdWlyZWQnKVxuXG4gIC8vIGxuZ2l0dWRlcyBjYW5ub3QgZXh0ZW5kcyBiZXlvbmQgKy8tOTAgZGVncmVlc1xuICBpZiAobG5nID4gMTgwIHx8IGxuZyA8IC0xODApIHtcbiAgICBsbmcgPSBsbmcgJSAzNjBcbiAgICBpZiAobG5nID4gMTgwKSBsbmcgPSAtMzYwICsgbG5nXG4gICAgaWYgKGxuZyA8IC0xODApIGxuZyA9IDM2MCArIGxuZ1xuICAgIGlmIChsbmcgPT09IDApIGxuZyA9IDBcbiAgfVxuICByZXR1cm4gbG5nXG59XG5cbi8qKlxuICogR2V0IHRoZSBzbWFsbGVzdCB0aWxlIHRvIGNvdmVyIGEgYmJveFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBCQm94XG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gdGlsZSBUaWxlXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbGUgPSBiYm94VG9UaWxlKFstMTc4LCA4NCwgLTE3NywgODVdKVxuICogLy89dGlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmJveFRvVGlsZSAoYmJveENvb3Jkcykge1xuICB2YXIgbWluID0gcG9pbnRUb1RpbGUoW2Jib3hDb29yZHNbMF0sIGJib3hDb29yZHNbMV1dLCAzMilcbiAgdmFyIG1heCA9IHBvaW50VG9UaWxlKFtiYm94Q29vcmRzWzJdLCBiYm94Q29vcmRzWzNdXSwgMzIpXG4gIHZhciBiYm94ID0gW21pblswXSwgbWluWzFdLCBtYXhbMF0sIG1heFsxXV1cblxuICB2YXIgeiA9IGdldEJib3hab29tKGJib3gpXG4gIGlmICh6ID09PSAwKSByZXR1cm4gWzAsIDAsIDBdXG4gIHZhciB4ID0gYmJveFswXSA+Pj4gKDMyIC0geilcbiAgdmFyIHkgPSBiYm94WzFdID4+PiAoMzIgLSB6KVxuICByZXR1cm4gW3gsIHksIHpdXG59XG5cbmZ1bmN0aW9uIGdldEJib3hab29tIChiYm94KSB7XG4gIHZhciBNQVhfWk9PTSA9IDI4XG4gIGZvciAodmFyIHogPSAwOyB6IDwgTUFYX1pPT007IHorKykge1xuICAgIHZhciBtYXNrID0gMSA8PCAoMzIgLSAoeiArIDEpKVxuICAgIGlmICgoKGJib3hbMF0gJiBtYXNrKSAhPT0gKGJib3hbMl0gJiBtYXNrKSkgfHxcbiAgICAgICgoYmJveFsxXSAmIG1hc2spICE9PSAoYmJveFszXSAmIG1hc2spKSkge1xuICAgICAgcmV0dXJuIHpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTUFYX1pPT01cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///DeP4\n")}}]);